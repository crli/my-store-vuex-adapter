<doc>
    <h1>前言</h1>
    <p>Store技术是指vuex、redux等类elm的状态管理技术，这种技术如今在前端开发领域非常成熟，他与传统MVC相比，有支持视图嵌套、支持异步、支持响应式视图等优点。不过这些状态管理库也存在着缺陷：</p>
    <li>1.这些库往往和视图层技术是紧耦合的，视图层的框架生态绑架了我们整个app的实现技术，例如使用vuex和vue开发app，一旦弃用了vue，vuex的部分也将无法使用，整个app都将重写。</li>
    <li>2.store技术可以让我们的component不再管理状态，而是一个sfc，状态统一交给store技术去管理，不过这样控件就必须依赖于某一种store技术上，同一个state模型，在不同store技术中实现方法是不一样的，是否存在一种通用的定义和修改state的方法呢？</li>

    <h1>my-store-adapter</h1>
    <p><strong>my-store-adapter</strong>是一个store技术的适配器，其目的就是使用一套代码去适配多种store技术。因为各个store技术的实现库基于不同的理论，所以无法使用一种通用技术实现，如redux基于不可变数据，vuex基于getter和setter。my-store-adapter希望能够使用统一的方式实现redux的reduce和vuex的mutation。该项目前期仅支持redux、vuex，未来还会适配更多store库。</p>

    <h2>思路</h2>
    <p>软件开发原则中的依赖反转原则，指导我们的业务代码不能和框架代码依赖，思路是定义一个统一的状态更新门面，让用户的状态管理业务管理代码仅依赖于我们提供的门面接口。如果你不想让自己的业务代码依赖于我们的接口，我们还提供了注册你自己的适配器去让你去发自己的门面。然后我们提供了适配多种store技术的适配器，可以让依赖于门面实现的业务代码适配到各种store框架上面。</p>

    <h2>原理</h2>
    <p>store技术的核心是响应式开发，也就是观察者模式。每一种store技术的观察者实现是不一样的，比如redux使用的是不可变数据和数据diff，而vuex提供的是setter和getter，mobx是使用的观察者对象。让同一套代码去适配所有响应式框架几乎是不可能的，而响应式的根本，是实现对数据变化的监听，然后对其做出响应。my-store-adapter使用了ea6的动态代理监听对store修改的事件，my-store-adapter会记录state的每一次的修改的事件，我们再封装为适配store上面，我们会使用该store适用的技术去更新正在的state。同时将计算值，getter等概念在不能store技术上面实现。</p>

    <h2>规则</h2>
    <p>当然我们的适配也是要符合一定的规则</p>
    <li>1.纯函数：redux已经概括出纯函数在store技术中的好处，所以我们没有必要不去遵守</li>
    <li>2.反规则：适配器无法完全满足store</li>
    <li>3.自动克隆所赋的值：适配器规定，如果一个对象赋值给另一个对象的属性，需要对这个对象做深拷贝，这样是防止对象被多个对象引用或者循环引用，基于动态代理对setter的拦截，使得克隆是自动的，使用者无需手动克隆</li>
    <li>4.不处理异步：适配器本身不是store技术框架，我们只做store技术修改数据的适配，至于具体异步怎么处理里，你的store实现说了算</li>
    <li>5.不提供插件：同第上一条</li>

    <h2>额外功能</h2>
    <li>1.计算值：计算值是一些store技术的特色，但不是每一个store都拥有计算值，根据我们的适配器，我们可以在所有框架上面都实现计算值，不过计算值必须是只读的</li>
    
    <h2>性能</h2>
    <p>因为适配器的实现原理，理论上任何适配器的性能都会小于被包装库，更何况代理对象在对象每次读写操作时候都会创建。但是当数据层级不是很深，赋值操作不是很多时候，适配器对性能的影响可以忽略不计。适配器的适用范围就是简单的通用store技术的实现，让我们的业务逻辑可以脱离框架束缚，可以做到依赖反转</p>

    <h2>迁移</h2>
    <p>请查看各个适配器插件，里面记录着各种类库的迁移到适配器的具体方法</p>
    <p>vuex，mobx，redux，flux</p>

</doc>